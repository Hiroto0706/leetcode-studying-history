## https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/submissions/1804660756

> Example 1:<br>
> Input: nums = [-10,-3,0,5,9]<br>
> Output: [0,-3,9,-10,null,5]<br>
> Explanation: [0,-10,5,null,-3,null,9] is also accepted:<br><br>
> Example 2:<br>
> Input: nums = [1,3]<br>
> Output: [3,1]<br>
> Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.

与えられた照準の配列を木構造にするというもの。
照準の配列であれば、配列の真ん中を root にし、半分にした配列の真ん中を次の Node にするという操作を繰り返していけば、最終的に求めている木構造を作成することができる。

自分の回答は以下のようになった。

```ts
function sortedArrayToBST(nums: number[]): TreeNode | null {
  const build = (l: number, r: number): TreeNode | null => {
    if (l > r) return null;

    const mid = Math.floor((l + r) / 2);
    const node = new TreeNode(nums[mid]);
    node.left = build(l, mid - 1);
    node.right = build(mid + 1, r);
    return node;
  };

  return build(0, nums.length - 1);
}
```

build という関数が行っているのは第 1 引数（配列の開始一）、第 2 引数（配列の終端）を足して 2 で割ったものがその配列における真ん中になるので、それを見つけて node にして返すというもの。

その処理を再帰的に繰り返していけば、最終的に求めてる木構造を取得することができる。

こういった再帰的な処理を行えば求めている結果を得られるっていうのは、答えがわかれば理解できるのだが、何もないところから「あ、これ再起的にすればいいじゃん」ってどうやってわかるのだろうか？

<details>
<summary>再帰的な処理をする判断ってどうすればいいか</summary>
もんた、実装バッチリ！🔥
「どうやって“再帰だ”と見抜くの？」に答えるための**思考フレーム**置いてくね。

---

**🧭 再帰を見抜くサイン（セルフチェック）**

- **自己相似**：問題を小さくしても“同じ型の問題”になる
  例）配列の左右半分も「ソート済み配列 →BST」に同型で落ちる
- **サイズが縮む明確な分割点**がある
  例）真ん中 `mid` を切ると、左右が独立（左は左の BST、右は右の BST）
- **ベースケースが自然に立つ**
  例）区間が空になったら `null`
- **“最終物”が合成で作れる**
  例）`root = mid`、`root.left = 左の解`、`root.right = 右の解`
- **制約が分割選択を決め打ちにする**
  例）「高さバランス」「昇順」→ 真ん中を根にすると両辺の高さ差が最小化しやすい

---

**🧠 こう考えると再帰が浮かぶ（思考ルート）**

1. **逆算する**：「完成形の根は何？」
   → BST かつバランス良くしたい＝**真ん中が根**が自然

2. **根を決めたら残りは？**
   → 左右は「同じ問題の縮小版」＝**自己相似**が出現

3. **合成方式を決める**
   → `node.left = solve(left-subarray)` / `node.right = solve(right-subarray)`

4. **停止条件を置く**
   → 区間が空なら `null`

この 4 ステップが “再帰でいける” と腹落ちする黄金パターン ⚡️

---

**🧩 分割統治のテンプレ質問（毎回これを自問）**

- 分ける“軸”はある？（中央値・ピボット・境界・先頭など）
- 分けた後の**部分問題の型が同じ**か？
- **部分問題の解をどう合成**すると全体の解になる？
- **ベースケース**は何？（最小サイズの時どうする？）
- 時間計算量は**T(n) = T(left) + T(right) + 合成コスト**で OK？

今回なら：
分割＝`mid`、型＝同じ BST 構築、合成＝左右を子に繋ぐ、ベース＝空区間、T(n)=O(n)

---

**🪄 “再帰でいける”感を鍛える練習法**

- **根 → 部分木**の順で“構成を言語化”してからコード
  （「根を決める → 左右は同じこと → 止めどき」）
- **イテレーティブ化**も書いてみる（栄養満点）
  スタックに区間（l,r）を積み、`mid`でノードを作って左右を push
  → 再帰の“実体”が**スタックでの分割統治**だと腑に落ちる
- **類題を束で解く**

  - ソート済み LL→BST（真ん中の見つけ方がひと工夫）
  - 配列 → 高さ最小の BST（今回と同型）
  - 二分探索・クイックソート（“軸で割って再帰”同族）

---

**⚠️ つまずきポイントと回避メモ**

- `m` を**両側再帰に含めない**（`[l, m-1]` と `[m+1, r]`）
- ベースケース漏れによる**無限再帰**
- 「偶数長でどっちが根？」問題は**どっちでも OK**（仕様が許容）

---

**🎯 次のアクション（ぶち上げプラン）**

- 同じ実装を**イテレーティブ（スタック）**で書いてみる
- 「ソート済み**連結リスト**→BST」も同発想で撃破
- 「どの分割軸が“自然”か？」を毎回言語化してから実装開始

この型が体に入ると、分割統治系は一気に無双できるよ。いい走りだ、もんた！🔥

</details>

イテレーディブかつ同じような処理が繰り返し実行されるような場合において、再帰的な処理を使えるっていう理解でいいのかな。

お、この処理求めている回は同じ処理を繰り返して値を return していけば求められるな → 再帰処理 or イテレーティブっていう理解でいいかな。

<details>
<summary>フィードバック</summary>
うんっっっ！！！💥
その理解、**ドンピシャで正しい方向**に来てるもんた！！！👏👏👏

ただし、もう一歩だけ掘っておくと「再帰」と「イテレーティブ」は**“処理の流れ”は同じ**だけど、**“管理の仕方”が違う**んだ。そこを理解しておくと判断がもっとクリアになる 🔥

---

### ⚙️ ざっくり整理すると…

| 観点           | 再帰（Recursive）                                            | イテレーティブ（Iterative）                                |
| -------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 状態の管理     | コールスタックに**自動で積まれる**                           | 明示的に**stack/queue 変数で管理する**                     |
| コードの見通し | シンプルで直感的                                             | 手動で制御が必要だけど、パフォーマンスに優れる             |
| 向いてる場面   | 問題が“自己相似”で、1 ステップごとに**部分問題に分けられる** | 大量データ・深い再帰（スタックオーバーフローが心配）な場合 |
| 例             | DFS, 分割統治（クイックソート、マージソート、木構築）        | BFS, Stack/Queue を使う探索、ループ処理                    |

---

### 🧭 もんたの理解を補強する「判断軸」

> 「同じ処理を繰り返してるな → 再帰 or ループで表せそう」

ここまでは OK！
そこに**＋もう一問だけ**自問してみて 👇

> 「処理を小さく分けた時、“残りの部分”も**同じ形の問題**になってるか？」

これが YES なら → **再帰で書ける問題**（自己相似構造）
NO なら → 単純なループで十分な問題（線形反復で OK）

---

### 💡 具体例でいうと…

| 問題                 | 再帰？                  | 理由                                                |
| -------------------- | ----------------------- | --------------------------------------------------- |
| ソート済み配列 →BST  | ✅ 再帰                 | 左右の部分配列も「ソート済み →BST」という同型の問題 |
| フィボナッチ         | ✅ 再帰可（でも非効率） | n→(n-1)+(n-2)という自己相似構造                     |
| 配列の合計値を求める | ❌ 再帰も可だが不要     | 単純な線形処理。状態が自己相似でない                |
| 木の深さを求める     | ✅ 再帰 or Stack        | 各ノードの“部分木”が同じ構造の問題                  |
| BFS で探索           | ❌ ループが自然         | 再帰も可だが Queue を使った反復が効率的             |

---

### 🔥 つまりまとめると！

> **「同じ形の問題が、部分として再登場する」 → 再帰で書ける！** > **「同じ処理を、同じ状態で繰り返すだけ」 → ループで書くのが自然！**

---

そして極論を言うと、
💬 **「再帰 = イテレーティブ + 自動スタック」**
っていう感覚があれば完璧 ✨

---

もんたの今の理解（「繰り返し＋値の return」）はすでに**本質の入口**に立ってる。
ここから「自己相似構造」をキーワードに磨いていけば、
アルゴリズムの設計力が一気に跳ねる 🔥

---

次のステップとして、
👉 同じ BST 問題を**stack でイテレーティブに書く練習**してみるのオススメ。
それやると「再帰の中で実は何が行われてるのか」が**完全に見える化**される。

やってみる？（再帰 →stack 変換トレーニング 🔥）

</details>
