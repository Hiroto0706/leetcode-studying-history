## https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/1799897275

> Example 1:<br
> Input: nums1 = [1,3], nums2 = [2]
> Output: 2.00000
> Explanation: merged array = [1,2,3] and median is 2.<br><br>
> Example 2:<br>
> Input: nums1 = [1,2], nums2 = [3,4]
> Output: 2.50000
> Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.

この問題は上記のように二つの配列の中央値を見つけるというもの。
また、縛りとして計算量は O(log (m+n))である必要がある。

私の回答としては以下のようになった

```ts
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
  let a = nums1.length <= nums2.length ? nums1 : nums2;
  let b = nums1.length <= nums2.length ? nums2 : nums1;

  const total = a.length + b.length;
  const isEven = total % 2 === 0;

  const k1 = Math.floor((total + 1) / 2);
  const k2 = Math.floor((total + 2) / 2);

  const kth = (a: number[], b: number[], k: number): number => {
    while (true) {
      if (a.length === 0) return b[k - 1];
      if (b.length === 0) return a[k - 1];
      if (k === 1) return Math.min(a[0], b[0]);

      const i = Math.min(a.length, Math.floor(k / 2));
      const j = k - i;
      const ai_1 = a[i - 1];
      const bj_1 = b[j - 1];

      if (ai_1 <= bj_1) {
        a = a.slice(i);
        k -= i;
      } else {
        b = b.slice(j);
        k -= j;
      }
    }
  };

  if (isEven) {
    return (kth(a, b, k1) + kth(a, b, k2)) / 2;
  } else {
    return kth(a, b, k1);
  }
}
```

とはいっても、正直全く答えが分からず AI に質問しながら回答した。
また、答えを見ても全く分からなかったので、ここからはなぜこのコードで通るのかの理解を進めていくことにする。

一応 AI からの解説はこちら。

<details>
<summary>AIからの超詳しい解説</summary>
いいよ、ここは “なぜそれで正しいのか” に全振りで、超ていねいに分解するね。
結論から言うと、この手法は

1. 「中央値＝ k 番目の要素」に言い換える
2. 2 つの**ソート済み**配列から、**k/2 個単位で“絶対に答えにならない塊”を捨てる**
3. 残り問題の「k（順位）」を減らしながら繰り返す（=二分法）

という仕組みで動く。だから **O(log(m+n))**。

---

# 0. 中央値を「k 番目の要素」に言い換える

- 長さ合計 `T = m + n`
- **奇数**：中央値 = **`k = (T+1)/2` 番目**（1-index）
- **偶数**：中央値 = **`k1 = T/2` 番目** と **`k2 = k1+1` 番目**の平均

つまり「`kth(A,B,k)` があれば median は出せる」。
以降は **k 番目最小**を求める関数 `kth(A,B,k)` の正しさを説明する。

---

# 1. 常に成り立つ“不変条件（invariant）”

アルゴリズムの各ループで、次の事実をずっと保つ：

- A, B は**それぞれ**ソート済み
- 「元の配列の中で **k 番目** を探している」問題が、**“今の A, B”** に**縮小**されている
  → 捨てた要素は「k 番目より前に確定」なので、**もう二度とその中に答えはない**

この “k の意味（残りの世界での順位）を正しく保ってる” が肝。

---

# 2. 1 回のループで何をしているか

## ステップ A：ベースケース

- どちらかが空：残ってる方の `k-1` 番目が答え
- `k === 1`：A[0] と B[0] の **小さい方**が答え（「最小」を取るだけ）

## ステップ B：k/2 ずつ「候補の塊」を比べる

- `i = min(|A|, floor(k/2))`
- `j = k - i`（左右で合計 `k` 個になるよう割り当て）
- 比べるのは **境界の 2 個**：`A[i-1]` と `B[j-1]`

### もし `A[i-1] <= B[j-1]` なら？

- A の先頭 `i` 個 **全部**が、**全体の k 個の左側**に収まる（B 側の `j` 個の最後が `B[j-1]` で、それより A[i-1] が小さいのだから、A の先頭 i 個は **k 番目より前**に確定）
- よって **A の先頭 i 個は答えになり得ない** → まとめて捨てる
- 問題を `k -= i`, `A = A[i:]` に**縮小**する（B はそのまま）

### 逆に `B[j-1] < A[i-1]` なら？

- 同理で **B の先頭 j 個を捨てる** → `k -= j`, `B = B[j:]`

> 一言で言うと：
> **境界の小さい方の“塊”は、まとめて前側に確定** → だから**丸ごと捨てて良い**。

---

# 3. 具体例で“捨てていい理由”を体感する

### 例 1（奇数合計）

A=[1,3], B=[2], `k=2`（=中央値）

- `i=1, j=1` → 比較 `A[0]=1` vs `B[0]=2` → **1 ≤ 2**
- A の先頭 1 個（=1）は、**k=2 の前側**に確定 → 捨てる

  - A=[3], B=[2], k=1

- `k=1` なので **min(3,2)=2** が答え（=中央値）

> 捨てたもの（1）は“1 番目領域”に確定したので、**2 番目**（= 今の k）にはなり得ない。

---

### 例 2（偶数合計、k1=2, k2=3）

A=[1,2], B=[3,4]

- **k1=2**

  - `i=1, j=1`、比較 1 vs 3 → A の 1 個捨て → A=[2], k=1 → **min(2,3)=2**

- **k2=3**

  - `i=1, j=2`、比較 1 vs 4 → A の 1 個捨て → A=[2], k=2
  - `i=1, j=1`、比較 2 vs 3 → A の 1 個捨て → A=[], k=1
  - 片側空＋ k=1 → **B[0]=3**

- 中央値 = (2+3)/2 = **2.5**

> 毎回「境界の小さい側の塊を捨てる」だけで、ちゃんと k が近づき、最後にベースケースで決着。

---

### 例 3（あなたの k=4 例）

A=[5,7,8,11], B=[4,9,12,14], k=4

1. `i=2, j=2` 比較 7 vs 9 → **A の[5,7]（2 個）捨て** → A=[8,11], k=2
2. `i=1, j=1` 比較 8 vs 4 → **B の[4]（1 個）捨て** → B=[9,12,14], k=1
3. `k=1` → **min(8,9)=8**（これが 4 番目）

> 捨てた [5,7] も [4] も、**4 番目より前**であることが境界比較から保証されているから、安心して落とせる。

---

# 4. なぜ “境界の小さい側を丸ごと捨てて良い” のか（直感＋ちょい形式）

- `A[i-1] <= B[j-1]` なら、A の先頭 `i` 個は **全て** `B[j-1]` 以下
- 一方、B の左側 `j` 個の最後は `B[j-1]`
  → よって、A の先頭 `i` 個は「左側 `i+j = k` 個」に確実に含まれる
  → **k 番目**（左側一番右）では**ない**（せいぜい k−1 まで）
  → だから **A の先頭 i 個は答えになり得ない**＝**捨てて OK**

同様に、`B[j-1] < A[i-1]` なら B の先頭 `j` 個を捨てて良い。

---

# 5. 端・例外処理がうまくいく理由

- `i = min(|A|, floor(k/2))` とすることで、**短い方の越境**を防ぐ
- `k === 1` なら **min(A[0], B[0])**（“最小”を取るだけ）
- どちらかが空配列になったら、**残り配列の k-1 番目**が答え（ソート済みなので即決）

この 3 つの分岐があるから、ループの中は “境界比較で捨てるだけ” に集中できる。

---

# 6. 計算量が O(log(m+n)) になる直感

毎ステップで **少なくとも `floor(k/2)` 個**を捨てるので、k は **指数的**に減る。
だからステップ数は **log k ≤ log(m+n)**。
各ステップで見てるのは境界の 定数個（最大 2 個）だけ → **合計 O(log(m+n))**。

---

# 7. よくハマる落とし穴

- **マージしてから**中央を取る → O(m+n) で要件違反
- `i, j` の計算で空配列越境（`i=0` や `j=0` になり得る場所の参照に注意）
- 偶数ケースで **k1, k2 を別々に**求めて平均、を忘れる
- `left`/`right` を動かす型の二分探索（配列片側のパーティション法）と、この **k 番目スキップ法**を混同する

---

# 8. ここまでの理解の“1 行要約”

> **境界 2 つ（A[i−1], B[j−1]）の小さい側の塊は、k 番目より前に“全部”確定する**。
> だからそれを丸ごと捨て、**k を減らして問題を縮小**する。
> これを繰り返すと、最後は `k==1`（最小を取るだけ）か片側空に到達して答えが出る。

---

ここまでで「なぜ捨てていいか（安全性）」と「なぜ速いか（k を半分ずつ減らす）」が腹落ちすれば OK。
もし特定のケースで「次にどっちを捨てるべきか迷う」場面があれば、その時点の `A, B, k, i, j, A[i-1], B[j-1]` を書いて見せて。そこをピンポイントで一緒に手計算するよ。

</details>

なるほど、 `i + j = k`である以上、a[i-1], b[j-1]が答えの中央値になりえることはない。
だから、a[i-1], b[j-1]を比較して、a から i だけ要素を削除しても問題ないって感じか。

よく分かっていないのが、k=1 になった時になんで a[0],b[0]で答えになるのかってところ。
もともと `k = (total + 1)/ 2;`自体が答えを表しているのは確定しており、そこから中央値になり得ない要素を削除していき、最終的に k=1 になった、あり得ない値を全て削除したから、答えになるよねみたいなこと？

<details>
<summary>フィードバック</summary>
めちゃくちゃ良い理解方向に進んでる👏
そう、もう9割正解なんだけど、
「なぜ k=1 の時 min(a[0], b[0]) が答えになるのか」を
“直感と理屈の両方”で説明しよう。

---

## 💡 前提のおさらい

アルゴリズム中では

> 「**これまでに削除してきた要素**は、全部 “k 番目より前” に確定している」

という不変条件（invariant）が常に保たれている。

つまり、ループが進むたびに
「この世界（A, B）の中で、**次に探すのは “残りの中で k 番目の要素”**」
という状態を維持してる。

---

## ✅ じゃあ「k=1」になったときって何を意味する？

それはつまり、

> “残っている A, B の中で、**最小の要素が**全体の k 番目（=1 番目）である”

ということ。

---

## 🧠 例で見ると一瞬で納得できる

### 例：

A = [5, 7, 8, 11]
B = [4, 9, 12, 14]
k = 4（最初）

1️⃣ 比較 a[i−1]=7, b[j−1]=9 → A の前 2 個（5,7）削除
　 → A=[8,11], B=[4,9,12,14], k=2
2️⃣ 比較 a[i−1]=8, b[j−1]=4 → B の 1 個（4）削除
　 → A=[8,11], B=[9,12,14], k=1
📍 この時点で「A,B の中の **次の 1 番目の要素**」が欲しい

→ つまり、「**今残っている全体の中で一番小さい値**」が答え。

- A の最小値 = A[0] = 8
- B の最小値 = B[0] = 9
  → `min(8,9)=8` が「次の 1 番目の要素」＝求める答え。

---

## ⚙️ もう少し形式的に説明するなら

> ループが進むたびに、
>
> - A の先頭 x 個
> - B の先頭 y 個
>   が「**確実に k 番目より前**」と確定している。

そして k が 1 になるとは：

> “この時点で削除済み要素数 + 1 = 本来の k 番目”

ということ。
だから残ってる要素の中で**最小の値がちょうど次の 1 番目（=目的の k 番目）**。

---

## 🧩 イメージ図

```
削除済み: |1|2|3| ← ここまでは「k番目より前」
残り:      |4|5|6| ← この先頭（最小）が「4番目」つまり k=1 の対象
```

だから `min(a[0], b[0])` が “次に来るべき順位 1 番目” ＝ **k 番目** ってこと。

---

## 💬 一言でまとめると

> **k は「残っている世界での順位」だから、k=1 になった時点で “最小値” が答え。**
> もうそれ以上小さい要素は全部削除済みだから。

---

これが理解できてると、「k を更新する意味」や「a.slice(i), k -= i」の重要性が
直感で分かるようになる。

---

もんたの言葉で表現するとしたら、

> 「最初に求めたいのは (m+n+1)/2 番目の要素。
> あり得ない値をどんどん削っていって、
> 最後に '残りの中で 1 番目' = '全体で中央値' になる」

まさにその通り ✨

</details>

あ〜、なるほど k はそもそも全体における中央値を意味しているのか。
そして、while の中の計算にて、中央値になり得ないものを削除していき、その都度 k も調整して行っている。(例：k-=i, k-=j がそう)
そのため、全体から見た時に中央の位置は変わっていないので問題なしってことか。

んで、最終的に k=1 になったとき=k になり得ないものを全て削除したので、a[0], b[0]を返せば OK ってことね。

<details>
<summary>フィードバック</summary>
そうそう！理解バッチリだよ👏

- **k は「残っている世界での“順位”」**（最初は全体の中央値の順位）。
  ループで **“答えになり得ない塊”を削除**し、その分 **k を減らす（`k -= i` / `k -= j`）**。
  → これで「求めたい順位」が常に保たれる（不変条件）。

- **k=1** になったら、残っている要素の中の **最小値**＝`min(a[0], b[0])` が答え。
  それより小さいものは全部「先に捨てられて」いるから。

補足だけサクッと 👇

- 奇数長なら `k = floor((m+n+1)/2)` を 1 回。
- 偶数長なら **`k1 = floor((m+n)/2)` と `k2 = k1+1` を別々に求めて平均**。
- 各ステップの比較は **境界 2 個（`A[i-1]` と `B[j-1]`）** だけ見れば OK。
- `i = min(|A|, floor(k/2))`、`j = k - i` で **短い方の越境を防ぐ**。
- 端では **空配列の処理**と **`k===1`** を先に返すのが安定。

この“順位の不変条件”が腹に落ちてるなら、もう実装は一直線だよ ✨

</details>
